
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://fhyhyfoqzpkzkxbkqcdp.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZoeWh5Zm9xenBremt4YmtxY2RwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY1NjY0ODIsImV4cCI6MjA2MjE0MjQ4Mn0.NluvL4FiDbgKXu_avMaLUgyzQayV4_15vrH64vWfok0";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    storage: typeof window !== 'undefined' ? localStorage : undefined,
    flowType: 'implicit',
  },
  global: {
    headers: {
      'Cache-Control': 'no-cache',
      'Pragma': 'no-cache',
      'X-Client-Info': 'supabase-js/2.x'
    },
    fetch: (url, options) => {
      const timeout = 30000; // 30 seconds
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      return fetch(url, {
        ...options,
        signal: controller.signal,
      }).finally(() => clearTimeout(timeoutId));
    }
  },
  db: {
    schema: 'public',
  },
  realtime: {
    params: {
      eventsPerSecond: 100,
    }
  }
});

// Simple retry mechanism
const handleRequestWithRetry = async (requestFn: () => Promise<any>, maxRetries = 3) => {
  let retries = 0;
  
  while (retries < maxRetries) {
    try {
      return await requestFn();
    } catch (error) {
      retries++;
      console.error(`Request failed (attempt ${retries}/${maxRetries}):`, error);
      
      if (retries >= maxRetries) {
        throw error;
      }
      
      const delay = 1000 * Math.pow(2, retries);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
};

// Monitor authentication state
supabase.auth.onAuthStateChange((event, session) => {
  if (event === 'SIGNED_OUT') {
    console.log('User signed out');
  } else if (event === 'USER_UPDATED') {
    console.log('User session updated');
  }
});

// Simplified fetchAllRecords function with better type safety
export const fetchAllRecords = async (
  tableName: 'admins' | 'voters',
  options: {
    filters?: Record<string, any>;
    orderBy?: string;
    ascending?: boolean;
  } = {}
): Promise<any[]> => {
  const { filters = {}, orderBy = 'created_at', ascending = true } = options;
  const allResults: any[] = [];
  
  console.log(`üöÄ Fetching all records from ${tableName}`);

  try {
    // Get total count first
    let expectedCount = 0;
    try {
      const { count, error: countError } = await supabase
        .from(tableName)
        .select('*', { count: 'exact', head: true });
      
      if (!countError && count !== null) {
        expectedCount = count;
        console.log(`üìä Expected records: ${expectedCount}`);
      }
    } catch (e) {
      console.warn("Count failed, proceeding without expected count");
    }
    
    // Strategy 1: Try to get all records in one query
    try {
      console.log("üéØ Attempting single query...");
      
      let query = supabase.from(tableName).select('*');
      
      // Add ordering
      query = query.order(orderBy, { ascending });
      
      // Apply filters
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== null && value !== '') {
          query = query.eq(key, value);
        }
      });

      const { data: allData, error: allError } = await query;
      
      if (!allError && allData && allData.length > 0) {
        console.log(`‚úÖ Single query SUCCESS: Got ${allData.length} records`);
        return allData;
      }
    } catch (singleQueryError) {
      console.warn("Single query failed:", singleQueryError);
    }
    
    // Strategy 2: Use batching if single query fails
    console.log("üîÑ Using batching strategy...");
    
    const BATCH_SIZE = 1000;
    const MAX_ITERATIONS = 100;
    let offset = 0;
    let iteration = 0;
    let consecutiveEmpty = 0;
    
    while (iteration < MAX_ITERATIONS && consecutiveEmpty < 3) {
      try {
        console.log(`üì¶ Batch ${iteration + 1}: offset ${offset}, size ${BATCH_SIZE}`);
        
        let batchQuery = supabase.from(tableName).select('*');
        
        // Add ordering
        batchQuery = batchQuery.order(orderBy, { ascending });
        
        // Add range
        batchQuery = batchQuery.range(offset, offset + BATCH_SIZE - 1);
        
        // Apply filters
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined && value !== null && value !== '') {
            batchQuery = batchQuery.eq(key, value);
          }
        });

        const { data: batchData, error: batchError } = await batchQuery;
        
        if (batchError) {
          console.error(`Batch ${iteration + 1} error:`, batchError);
          break;
        }
        
        if (batchData && batchData.length > 0) {
          allResults.push(...batchData);
          consecutiveEmpty = 0;
          console.log(`‚úÖ Batch ${iteration + 1}: +${batchData.length} records (total: ${allResults.length})`);
          
          // If we got less than expected, we might be done
          if (batchData.length < BATCH_SIZE) {
            console.log("üìã Received partial batch, likely at end");
            break;
          }
          
          offset += batchData.length;
        } else {
          consecutiveEmpty++;
          console.log(`‚ùå Empty batch ${iteration + 1} (${consecutiveEmpty}/3)`);
          offset += BATCH_SIZE;
        }
        
        iteration++;
        
        // Small delay to prevent overwhelming the server
        if (iteration % 10 === 0) {
          await new Promise(resolve => setTimeout(resolve, 50));
        }
        
      } catch (batchError) {
        console.error(`Batch ${iteration + 1} exception:`, batchError);
        break;
      }
    }
    
    // Remove duplicates based on ID
    const uniqueResults = allResults.reduce((acc, record: any) => {
      if (!acc.find((r: any) => r.id === record.id)) {
        acc.push(record);
      }
      return acc;
    }, [] as any[]);
    
    const finalCount = uniqueResults.length;
    console.log(`üèÅ FINAL RESULT: ${finalCount} unique records`);
    
    if (expectedCount > 0) {
      const percentage = ((finalCount / expectedCount) * 100).toFixed(1);
      console.log(`üìà Completeness: ${percentage}% (${finalCount}/${expectedCount})`);
    }
    
    return uniqueResults;
    
  } catch (error) {
    console.error('‚ùå CRITICAL ERROR in fetchAllRecords:', error);
    throw error;
  }
};

// Legacy compatibility
export const fetchPaginated = fetchAllRecords;
